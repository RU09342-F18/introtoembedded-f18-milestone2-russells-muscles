#include <msp430.h>
#include <math.h>


float temp = 0;
float R=0;
int inttemp;
int DTemp = 20;
int TempDifference;
float adc;

int CUART(){

    P4SEL |= BIT4+BIT5;
    UCA1CTL1 |= UCSWRST;
    UCA1CTL1 |=UCSSEL_2;
    UCA1BR0= 6;
    UCA1BR1= 0;
    UCA1MCTL |= UCBRS_0 +UCBRF_13 + UCOS16;
    UCA1CTL1 &= ~UCSWRST;
    UCA1IE |=UCRXIE;
   // UCA1IE |=UCTXIE;

}
int CHPWM(){
    P2DIR |= BIT0;
    P2SEL |= BIT0;
    P2OUT &= ~BIT0;

    TA1CCR0 = 512;
    TA1CCTL0 = CCIE;

    TA1CCTL1 = OUTMOD_7;
    TA1CCR1 = 0;
    TA1CTL = TASSEL_2 + MC_1 + TACLR;


}
int CADC(){
    ADC12CTL0 = ADC12SHT02 + ADC12ON;         // Sampling time, ADC12 on
     ADC12CTL1 = ADC12SHP;                     // Use sampling timer
     ADC12IE = 0x01;                           // Enable interrupt
     ADC12CTL0 |= ADC12ENC;
     P6SEL |= 0x01;                            // P6.0 ADC option select
     P1DIR |= 0x01;                            // P1.0 output
}
int resetPWM(){


    TempDifference = inttemp - DTemp;
    if(TempDifference > 0)
    {
        if(TempDifference <= 2)
        {
            TA1CCR1  = 355;
        }
        else
        {
           TA1CCR1 = 450 + TempDifference * 5;

        }



    }
    else{

      TA1CCR1  = 350;

    }
    if (TempDifference <= 0)
    {
        if(TempDifference > -3)
        {
        TA1CCR1 = 10;
        }
        else
        {
            TA1CCR1 = 0;
        }
    }


}
int main(void)
{
  WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
  CHPWM();
  CADC();
  CUART();
  P4DIR |= BIT7;
  P4OUT &= ~BIT7;

  while (1)
  {
                       // Start sampling/conversion
       ADC12CTL0 |= ADC12SC;
         // LPM0, ADC12_ISR will force exit




        __bis_SR_register(LPM0_bits + GIE);
  }
}

#pragma vector = ADC12_VECTOR
__interrupt void ADC12_ISR(void)

{
    switch(__even_in_range(ADC12IV,34))
      {
      case  0: break;                           // Vector  0:  No interrupt
      case  2: break;                           // Vector  2:  ADC overflow
      case  4: break;                           // Vector  4:  ADC timing overflow
      case  6:                                  // Vector  6:  ADC12IFG0
    P4OUT ^= BIT7;
    adc = ADC12MEM0;
    R = (adc*(3.3/4096)*10000)/(3.3 - (adc*(3.3/4096)));
           if (R<=15698 && R>=5933)//checks if resistance is between 15 degrees and 35degrees
               temp= -0.0022 * R + 47.71;
             else if(R<=5933 && R>=1919)//checks if resistance is between 40 degrees and 65degrees
                 temp= -0.0076 * R + 78.917;
             else // if(TA0CCR0>70 && TA0CCR0<100)//checks if resistance is between 70 degrees and 100degrees
                 temp= -0.0275 * R+ 116.24;

           temp = temp + 0.5;

           inttemp = (int) temp;

     // Exit active CPU, SET BREAKPOINT HERE
    resetPWM();
    break;
      }
}
#pragma vector=USCI_A1_VECTOR
__interrupt void USCI_A1_ISR(void)
{
    DTemp = UCA1RXBUF;

    UCA1IFG &= ~BIT0;

}
#pragma vector = TIMER1_A0_VECTOR                   // Detects interrupt for CCR0 on Timer1
__interrupt void Timer_A00(void)
{
    ADC12CTL0 |= ADC12SC;
       while(!(UCA1IFG & UCTXIFG));
       UCA1TXBUF = inttemp;


}

