#include <msp430.h>
#include <math.h>


float temp = 0;
float R=0;
int inttemp =0;
int DTemp;
int TempDifference;


int CUART(){

    P4SEL |= BIT4+BIT5;
    UCA1CTL1 |= UCSWRST;
    UCA1CTL1 |=UCSSEL_2;
    UCA1BR0= 6;
    UCA1BR1= 0;
    UCA1MCTL |= UCBRS_0 +UCBRF_13 + UCOS16;
    UCA1CTL1 &= ~UCSWRST;
    UCA1IE |=UCRXIE;
    UCA1IE |=UCTXIE;

}
int CHPWM(){
    P1DIR |= BIT2;
    P1SEL |= BIT2;
    P1OUT &= ~BIT2;
    TA0CTL = TASSEL_2 + MC_1 + ID_1 + TAIE;
    TA0CCR0 = 255;

    TA0CTL |= OUTMOD_7;
    TA0CCR1 = 0;

}
int CADC(){
    ADC12CTL0 = ADC12SHT02 + ADC12ON;         // Sampling time, ADC12 on
     ADC12CTL1 = ADC12SHP;                     // Use sampling timer
     ADC12IE = 0x01;                           // Enable interrupt
     ADC12CTL0 |= ADC12ENC;
     P6SEL |= 0x01;                            // P6.0 ADC option select
     P1DIR |= 0x01;                            // P1.0 output
}
int resetPWM(){

    int Speed;

    TempDifference = inttemp - DTemp;
    if(TempDifference >= 0)
    {
        if(TempDifference <= 2)
        {
            Speed = 20;
        }
        else
        {
            Speed = 20 + (TempDifference) * 5;
        }



    }
    else{

      Speed = 0;

    }
    TA0CCR1 = Speed;


}
int main(void)
{
  WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
  CHPWM();
  CADC();
  CUART();
//  CHPWM();

  while (1)
  {
    ADC12CTL0 |= ADC12SC;                   // Start sampling/conversion

    __bis_SR_register(LPM0_bits + GIE);     // LPM0, ADC12_ISR will force exit

     R = (ADC12MEM0*(3.3/4096)*10000)/(3.3 - (ADC12MEM0*(3.3/4096)));
       if (R<=15698 && R>=5933)//checks if resistance is between 15 degrees and 35degrees
           temp= -0.0022 * R + 47.71;
         else if(R<=5933 && R>=1919)//checks if resistance is between 40 degrees and 65degrees
             temp= -0.0076 * R + 78.917;
         else // if(TA0CCR0>70 && TA0CCR0<100)//checks if resistance is between 70 degrees and 100degrees
             temp= -0.0275 * R+ 116.24;

       inttemp = (int) temp;

       resetPWM();

  }
}

#pragma vector = ADC12_VECTOR
__interrupt void ADC12_ISR(void)

{
  switch(__even_in_range(ADC12IV,34))
  {
  case  6:                                  // Vector  6:  ADC12IFG0
      if (ADC12MEM0 >= 0x7ff)
      {
            P1OUT |= BIT0;}
        else
        {
            P1OUT &= ~BIT0;}
        __bic_SR_register_on_exit(LPM0_bits);   // Exit active CPU
  default:
      break;
  }
}
#pragma vector=USCI_A1_VECTOR
__interrupt void USCI_A1_ISR(void)
{
    if(!(UCA1IFG & UCTXIFG));             // USCI_A0 TX buffer ready?
    {
        UCA1TXBUF = inttemp;
    }
    if (!(UCA1IFG & UCRXIFG))
    {
        DTemp = UCA1RXBUF;
    }
    UCA1IFG &= ~BIT0;
//  switch(__even_in_range(UCA1IV,4))
//  {
//  case 0:
//      break;                             // Vector 0 - no interrupt
//  case 2:                                   // Vector 2 - RXIFG
//    while (!(UCA1IFG&UCTXIFG));             // USCI_A0 TX buffer ready?
//    UCA1TXBUF = temp;
//    break;
//  default:
//      break;
//  }
}
