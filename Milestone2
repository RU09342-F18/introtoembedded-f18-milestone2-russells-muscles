#include <msp430.h>
#include <math.h>


float temp = 0;
float R=0;
int inttemp;
int DTemp;
int TempDifference;
float adc;

int CUART(){

    P4SEL |= BIT4+BIT5;
    UCA1CTL1 |= UCSWRST;
    UCA1CTL1 |=UCSSEL_2;
    UCA1BR0= 6;
    UCA1BR1= 0;
    UCA1MCTL |= UCBRS_0 +UCBRF_13 + UCOS16;
    UCA1CTL1 &= ~UCSWRST;
    UCA1IE |=UCRXIE;
   // UCA1IE |=UCTXIE;

}
int CHPWM(){
    P1DIR |= BIT2;
    P1SEL |= BIT2;
    P1OUT &= ~BIT2;
    TA0CTL = TASSEL_2 + MC_1 + ID_3 + TAIE;
    TA0CCR0 = 1250;
    TA0CCTL0 = CCIE;

    TA0CTL |= OUTMOD_7;
    TA0CCR1 = 0;

}
int CADC(){
    ADC12CTL0 = ADC12SHT02 + ADC12ON;         // Sampling time, ADC12 on
     ADC12CTL1 = ADC12SHP;                     // Use sampling timer
     ADC12IE = 0x01;                           // Enable interrupt
     ADC12CTL0 |= ADC12ENC;
     P6SEL |= 0x01;                            // P6.0 ADC option select
     P1DIR |= 0x01;                            // P1.0 output
}
int resetPWM(){

    int Speed;

    TempDifference = inttemp - DTemp;
    if(TempDifference >= 0)
    {
        if(TempDifference <= 2)
        {
            Speed = 20;
        }
        else
        {
            Speed = 20 + (TempDifference) * 5;
        }



    }
    else{

      Speed = 0;

    }
    TA0CCR1 = Speed;


}
int main(void)
{
  WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
  CHPWM();
  CADC();
  CUART();
  P4DIR |= BIT7;
  P4OUT &= ~BIT7;

  while (1)
  {
    __bis_SR_register(LPM0_bits + GIE);                   // Start sampling/conversion

         // LPM0, ADC12_ISR will force exit

     R = (adc*(3.3/4096)*10000)/(3.3 - (adc*(3.3/4096)));
       if (R<=15698 && R>=5933)//checks if resistance is between 15 degrees and 35degrees
           temp= -0.0022 * R + 47.71;
         else if(R<=5933 && R>=1919)//checks if resistance is between 40 degrees and 65degrees
             temp= -0.0076 * R + 78.917;
         else // if(TA0CCR0>70 && TA0CCR0<100)//checks if resistance is between 70 degrees and 100degrees
             temp= -0.0275 * R+ 116.24;

       inttemp = (int) temp;
       while(!(UCA1IFG & UCTXIFG));
       UCA1TXBUF = inttemp;

       resetPWM();

  }
}

#pragma vector = ADC12_VECTOR
__interrupt void ADC12_ISR(void)

{
    P4OUT ^= BIT7;
    adc = ADC12MEM0;

  __bic_SR_register_on_exit(LPM0);   // Exit active CPU, SET BREAKPOINT HERE
}
#pragma vector=USCI_A1_VECTOR
__interrupt void USCI_A1_ISR(void)
{
    DTemp = UCA1RXBUF;

    UCA1IFG &= ~BIT0;

}
#pragma vector = TIMER0_A0_VECTOR                   // Detects interrupt for CCR0 on Timer1
__interrupt void Timer_A00(void)
{
    ADC12CTL0 |= ADC12SC;



}
#pragma vector=USCIAB1RX_VECTOR
__interrupt void USCI0RX_ISR(void) {

        DTemp = UCA1RXBUF;

}

